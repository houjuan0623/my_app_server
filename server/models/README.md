本文件夹中存放所有与数据库交互的模型。

# 权限表设计

使用四个数据库表（用户、角色、策略、资源）来实现 Casbin 的访问控制。

## 数据库collection解释

1. 用户表（users）
   用途：存储用户的个人信息和关联的角色。
   合理性：用户是访问控制决策的主体，因此需要一个表来管理他们的信息。将角色直接关联到用户使得角色分配更为直接和高效。
2. 角色表（roles）
   用途：定义角色以及角色之间的继承关系。
   合理性：角色是RBAC的核心概念。独立的角色表允许您灵活地定义和管理角色以及它们之间的关系，而不必在每次分配或更改角色时更改用户表。
3. 策略表（policies）
   用途：定义访问控制规则，即哪些角色可以对哪些资源进行什么操作。
   合理性：策略表是访问控制决策的核心。将策略独立出来可以更灵活地定义和管理访问权限，也便于进行更改和扩展。
4. 资源表（resources）
   用途：定义可被访问的资源，如界面元素、按钮等。
   合理性：资源表提供了对系统中所有资源的清晰定义，这对于精确的权限管理至关重要。

## 配置文件的解释

```
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
```

[request_definition]

r = sub, obj, act
这定义了访问请求的结构。r 表示请求，sub 是主体（比如用户），obj 是对象（即要访问的资源），act 是动作（如 read、write）。
[policy_definition]

p = sub, obj, act
这定义了策略规则的结构。p 表示策略，它的结构与请求相同。每个 p 规则定义了允许哪些主体对哪些对象执行哪些动作。
[role_definition]

g = _, _
这定义了角色继承的结构。g 是角色，每个 g 规则定义了一个角色继承关系（例如，角色 A 继承角色 B 的权限）。这种写法支持角色的多继承。
[policy_effect]

e = some(where (p.eft == allow))
定义了策略的效果。在这个例子中，它指出如果有任何一个策略规则导致允许（allow），则最终效果是允许访问。
[matchers]

m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
匹配器定义了一个请求和策略是否匹配的逻辑。在这里，它检查请求的主体是否拥有角色或者直接等于策略中定义的主体，请求的对象和动作是否与策略中的相匹配。这种写法支持角色的空继承。
